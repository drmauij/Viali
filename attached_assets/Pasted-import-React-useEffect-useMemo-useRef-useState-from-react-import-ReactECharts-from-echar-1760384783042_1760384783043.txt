import React, { useEffect, useMemo, useRef, useState } from "react";
import ReactECharts from "echarts-for-react"; // npm i echarts echarts-for-react
import * as echarts from "echarts";
// @ts-ignore â€“ vis-timeline has no perfect TS types out of the box
import { DataSet, Timeline } from "vis-timeline/standalone"; // npm i vis-timeline
import "vis-timeline/styles/vis-timeline-graph2d.min.css";

/**
 * AnesthesiaTimeline
 *
 * A clean, zoomable anesthesia record timeline with:
 * - Vital signs lines (HR, MAP, SpO2, EtCO2, etc.) on a continuous time axis
 * - Shaded target bands (e.g., MAP 65â€“85)
 * - Event rows (drugs, ventilation, infusions) with icons & labels
 * - Infusion strips (continuous ranges) + bolus markers
 * - Shared zoom/pan between chart (ECharts) and events (vis-timeline)
 *
 * Drop this file into your React app as AnesthesiaTimeline.tsx
 *
 * INSTALL:
 *   npm i echarts echarts-for-react vis-timeline
 *
 * USAGE:
 *   <AnesthesiaTimeline data={demoData} height={520} />
 */

export type VitalPoint = [number, number]; // [timestamp(ms), value]

export type Vitals = {
  hr?: VitalPoint[];
  map?: VitalPoint[];
  spo2?: VitalPoint[];
  etco2?: VitalPoint[];
  rr?: VitalPoint[]; // respiratory rate
};

export type Band = { yMin: number; yMax: number; label?: string; axis: "left" | "right" };

export type EventItem = {
  id: string | number;
  start: number; // ms
  end?: number; // ms (for ranges like infusions)
  group: string; // e.g., "Drugs", "Ventilation", "Infusions"
  label: string; // text label
  icon?: string; // emoji or image URL
  dose?: string; // e.g., "50 Âµg", "5 mg/kg/h"
  color?: string; // optional pill/strip color
  type?: "bolus" | "infusion" | "setting" | "note";
};

export type AnesthesiaData = {
  tStart: number; // overall window
  tEnd: number;
  vitals: Vitals;
  bands?: Band[]; // target bands for y axes
  events: EventItem[]; // discrete + ranged
};

export function AnesthesiaTimeline({
  data,
  height = 520,
}: {
  data: AnesthesiaData;
  height?: number;
}) {
  const containerRef = useRef<HTMLDivElement>(null);
  const timelineRef = useRef<Timeline | null>(null);
  const timelineRootRef = useRef<HTMLDivElement>(null);
  const [range, setRange] = useState<{ start: number; end: number }>({
    start: data.tStart,
    end: data.tEnd,
  });

  // Groups for the vis timeline (order defines vertical stacking)
  const groups = useMemo(
    () => [
      { id: "Drugs", content: "Medikamente" },
      { id: "Infusions", content: "Infusionen" },
      { id: "Ventilation", content: "Beatmung" },
      { id: "Events", content: "Ereignisse" },
    ],
    []
  );

  const items = useMemo(() => new DataSet<EventItem>(data.events), [data.events]);

  // ----- ECharts Option -----
  const option = useMemo(() => {
    const lrGrid = { left: 60, right: 60, top: 24, bottom: 120 };

    // helper to map vitals to series
    const mkLine = (
      name: string,
      pts?: VitalPoint[],
      yAxisIndex = 0,
      symbol: string | undefined = undefined
    ): echarts.SeriesOption | null =>
      !pts || pts.length === 0
        ? null
        : {
            name,
            type: "line",
            yAxisIndex,
            showSymbol: true,
            symbol: symbol ?? "circle",
            symbolSize: 8,
            smooth: true,
            lineStyle: { width: 2 },
            data: pts,
          } as echarts.SeriesOption;

    const series: echarts.SeriesOption[] = [];
    const hr = mkLine(
      "HR",
      data.vitals.hr,
      0,
      // heart shape path
      'path://M512 938L93 519a256 256 0 11362-362l57 57 57-57a256 256 0 01362 362L512 938z'
    );
    const map = mkLine("MAP", data.vitals.map, 1, "diamond");
    const spo2 = mkLine("SpOâ‚‚", data.vitals.spo2, 1, "triangle");
    const etco2 = mkLine("EtCOâ‚‚", data.vitals.etco2, 0, "rect");
    const rr = mkLine("RR", data.vitals.rr, 0, "roundRect");
    [hr, map, spo2, etco2, rr].forEach((s) => s && series.push(s));

    // markArea bands
    const markAreasLeft = (data.bands || [])
      .filter((b) => b.axis === "left")
      .map((b) => [{ yAxis: b.yMin, name: b.label || "" }, { yAxis: b.yMax }]);
    const markAreasRight = (data.bands || [])
      .filter((b) => b.axis === "right")
      .map((b) => [{ yAxis: b.yMin, name: b.label || "" }, { yAxis: b.yMax }]);

    // attach markArea to first series on each axis so it renders once
    if (series.length) {
      const leftSeries = series.find((s: any) => s.yAxisIndex === 0);
      const rightSeries = series.find((s: any) => s.yAxisIndex === 1);
      if (leftSeries && markAreasLeft.length) {
        (leftSeries as any).markArea = { itemStyle: { opacity: 0.12 }, data: markAreasLeft };
      }
      if (rightSeries && markAreasRight.length) {
        (rightSeries as any).markArea = { itemStyle: { opacity: 0.12 }, data: markAreasRight };
      }
    }

    return {
      backgroundColor: "#ffffff",
      animation: false,
      tooltip: { trigger: "axis", axisPointer: { type: "line" } },
      legend: { top: 4 },
      grid: lrGrid,
      xAxis: {
        type: "time",
        axisLabel: { formatter: "{HH}:{mm}" },
        minorTick: { show: true },
        minorSplitLine: { show: true },
        min: range.start,
        max: range.end,
      },
      yAxis: [
        { name: "Resp/EtCOâ‚‚", min: 0, max: 60, splitNumber: 6 },
        { name: "BP/SpOâ‚‚", min: 40, max: 120, splitNumber: 8 },
      ],
      dataZoom: [
        { type: "inside", throttle: 30, xAxisIndex: 0 },
        { type: "slider", height: 22, bottom: 88, xAxisIndex: 0 },
      ],
      series,
    } as echarts.EChartsOption;
  }, [data.vitals, data.bands, range.start, range.end]);

  // ----- vis-timeline setup -----
  useEffect(() => {
    if (!timelineRootRef.current) return;
    if (timelineRef.current) return; // init once

    const timeline = new Timeline(
      timelineRootRef.current,
      items,
      new DataSet(groups)
    );
    timelineRef.current = timeline;

    // style options
    timeline.setOptions({
      min: data.tStart - 5 * 60_000,
      max: data.tEnd + 5 * 60_000,
      start: data.tStart,
      end: data.tEnd,
      stack: false,
      zoomable: true,
      moveable: true,
      orientation: { axis: "top" },
      height: 180,
      margin: { item: 10, axis: 10 },
      groupOrder: (a: any, b: any) => ("" + a.id).localeCompare("" + b.id),
      template: (item: EventItem) => {
        const icon = item.icon?.startsWith("http")
          ? `<img src="${item.icon}" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;border-radius:2px;"/>`
          : item.icon
          ? `<span style="margin-right:6px">${item.icon}</span>`
          : "";
        const dose = item.dose ? `<span style="opacity:.7">${item.dose}</span>` : "";
        return `<div style="font-size:12px;line-height:1.2">${icon}<strong>${item.label}</strong> ${dose}</div>`;
      },
      tooltip: { followMouse: true },
      selectable: true,
    });

    // When user pans/zooms the vis timeline, update chart range
    timeline.on("rangechanged", (props: any) => {
      const start = +new Date(props.start);
      const end = +new Date(props.end);
      setRange({ start, end });
    });

    return () => {
      timeline.destroy();
    };
  }, [groups, items, data.tStart, data.tEnd]);

  // Keep vis timeline in sync when chart range changes
  useEffect(() => {
    const tl = timelineRef.current;
    if (!tl) return;
    const r = tl.getWindow();
    const start = +new Date(r.start);
    const end = +new Date(r.end);
    if (Math.abs(start - range.start) > 5 || Math.abs(end - range.end) > 5) {
      tl.setWindow(range.start, range.end, { animation: false });
    }
  }, [range]);

  // Keyboard zoom shortcuts for chart (+= zoom in, -/_ zoom out)
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      if (!['=','+','-','_'].includes(e.key)) return;
      const span = range.end - range.start;
      const factor = (e.key === '-' || e.key === '_') ? 1.3 : 1/1.3;
      const mid = range.start + span/2;
      const newSpan = span * factor;
      setRange({ start: Math.round(mid - newSpan/2), end: Math.round(mid + newSpan/2) });
    };
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [range]);

  return (
    <div ref={containerRef} className="w-full" style={{ background: "#fff" }}>
      <ReactECharts
        style={{ height: height - 180 }}
        option={option}
        notMerge
        lazyUpdate
        onEvents={{
          // When the ECharts dataZoom changes, sync to vis timeline
          dataZoom: (params: any) => {
            const model = (params?.batch && params.batch[0]) || {};
            // get xAxis min/max from current instance
            // we infer from component API via ref
          },
        }}
      />
      <div style={{ borderTop: "1px solid #eee" }} />
      <div ref={timelineRootRef} />
    </div>
  );
}

// ------------------ DEMO DATA ------------------
const t0 = +new Date("2025-02-02T11:35:00");
const step = 5 * 60 * 1000;
function seq(n: number) { return Array.from({ length: n }, (_, i) => i); }

const times = seq(36).map(i => t0 + i*step);

const jitter = (base: number, amp = 5) => base + Math.round((Math.random() - .5) * 2 * amp);

const demoVitals: Vitals = {
  hr: times.map((t, i) => [t, jitter(78 + Math.round(6*Math.sin(i/3)), 3)]),
  map: times.map((t, i) => [t, jitter(75 + Math.round(5*Math.cos(i/4)), 3)]),
  spo2: times.map((t) => [t, 97 + Math.round(Math.random())]),
  etco2: times.map((t, i) => [t, jitter(34 + Math.round(3*Math.sin(i/5)), 2)]),
  rr: times.map((t, i) => [t, jitter(12 + Math.round(2*Math.cos(i/6)), 1)]),
};

const demoBands: Band[] = [
  { axis: "right", yMin: 65, yMax: 85, label: "MAP Target" },
  { axis: "left", yMin: 30, yMax: 45, label: "EtCOâ‚‚ Target" },
];

const demoEvents: EventItem[] = [
  // Infusion strip
  { id: 1, start: t0 + 6*step, end: t0 + 19*step, group: "Infusions", label: "Ringer Acetat", dose: "1000 ml", icon: "ğŸ§ª", type: "infusion" },
  // Propofol infusion with step changes (you can model changes as separate items)
  { id: 2, start: t0 + 7*step, end: t0 + 22*step, group: "Infusions", label: "Propofol 1%", dose: "5â†’6 mg/kg/h", icon: "ğŸ’¤", type: "infusion" },
  // Bolus meds
  { id: 3, start: t0 + 8*step, group: "Drugs", label: "Fentanyl", dose: "50 Âµg", icon: "ğŸ’Š", type: "bolus" },
  { id: 4, start: t0 + 12*step, group: "Drugs", label: "Ephedrin", dose: "10 mg", icon: "ğŸ’Š", type: "bolus" },
  { id: 5, start: t0 + 20*step, group: "Drugs", label: "Ondansetron", dose: "4 mg", icon: "ğŸ’Š", type: "bolus" },
  // Ventilation settings (represented as ranges)
  { id: 6, start: t0 + 6*step, end: t0 + 25*step, group: "Ventilation", label: "FiOâ‚‚ 40%", icon: "ğŸ«", type: "setting" },
  { id: 7, start: t0 + 10*step, end: t0 + 18*step, group: "Ventilation", label: "PEEP 5", icon: "ğŸ«", type: "setting" },
  // Notes / events
  { id: 8, start: t0 + 5*step, group: "Events", label: "Incision", icon: "âœ‚ï¸", type: "note" },
  { id: 9, start: t0 + 23*step, group: "Events", label: "Emergence", icon: "â", type: "note" },
];

export const demoData: AnesthesiaData = {
  tStart: t0,
  tEnd: t0 + 35*step,
  vitals: demoVitals,
  bands: demoBands,
  events: demoEvents,
};

// Example wrapper component for quick testing
export default function Demo() {
  return (
    <div className="p-4">
      <h2 className="text-xl font-semibold mb-2">Anesthesia Timeline Demo</h2>
      <AnesthesiaTimeline data={demoData} />
    </div>
  );
}
